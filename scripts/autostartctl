#!/usr/bin/env bash

##############################################
#	Author: Nidia Achrys
#	Project: autostartctl
#	Version: 1.0
#
#	Usage: autostartctl [command] [args]
# 
# Description:
#   This utility provides tools to create, edit, list, and print
#   XDG Autostart desktop entries.
##############################################

version='1.0'
author='Nidia Achrys'

#######################################################################
#							                Helper Functions						            #
#######################################################################

# Replacement for 'echo'
function PRINT()
{
	if [ -z "${1}" ]; then
		printf "\n"
	else
		printf "%b\n" "${1}"
	fi
}

# Retrieve the name of the script file
function SCRIPTNAME()
{
	PRINT "${0##*/}"
}

# Pauses script execution until the user presses ENTER
function pause()
{
	read -p "Press ENTER to continue..." cmd
}

# Converts a string to all lowercase characters
function lowercase()
{
	printf "${1}" | tr "[:upper:]" "[:lower:]"
}

# Error message for when an invalid command is used
function invalid()
{
	PRINT 
	PRINT "Invalid command \"${1}\". See \"`SCRIPTNAME` help\"."
	PRINT 
}

# Error message for when no command is used
function emptycmd()
{
	PRINT 
	PRINT "You must specify a subcommand. See \"`SCRIPTNAME` help\"."
	PRINT 
}

# Checks for a filename in $PATH (commands), if not found then exit with an error
function dependency()
{
	[[ ! `command -v ${1}` ]] && PRINT "'${1}' is required to run this program." && exit 1
}

# Prints the script name and version, as well as copyright, license notice, and 
# author name
function version()
{
	PRINT "`SCRIPTNAME` v${version}"
	PRINT "Copyright (C) `date +"%Y"` ${author}"
	PRINT "License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>."
	PRINT "This is free software: you are free to change and redistribute it."
	PRINT "There is NO WARRANTY, to the extent permitted by law."
	PRINT
	PRINT "Written by ${author}."
}

#######################################################################
#								              Core Code							                  #
#######################################################################

# Variables
XDG_AUTOSTART="${HOME}/.config/autostart"
[[ -z "${EDITOR}" ]] && EDITOR=nano

filename=''
file=''
name=''
generic=''
binary=''
icon=''
apptype=''
categories=''
path=''

# Functions
append() {
  tee -a ${XDG_AUTOSTART}/${filename}.desktop
}

err() {
  PRINT "[$(date +'%Y-%m-%dT%H:%M:%S%z')]: ${@}"
}

function TEMPLATE()
{
_template="
[Desktop Entry]
Name=${name}
Exec=${binary}
Type=${apptype}
Categories=${categories}
Hidden=true
"

[ -n "${generic}" ] && _template="${_template}\nGenericName=${generic}"
[ -n "${icon}" ] && _template="${_template}\nIcon=${icon}"
[ -n "${path}" ] && _template="${_template}\nPath=${path}"
}

makeEntry() {

  filename="${1}"
  name="${2}"
  binary="${3}"
  categories="${4}"
  icon="${5}"
  generic="${6}"
  path="${7}"
  apptype="${8}"

  [[ -z "${filename}" ]] && read -p "New Entry Name: " filename
  [[ -z "${name}" ]] && read -p "App Name: " name
  [[ -z "${binary}" ]] && read -p "Executable Path: " binary
  [[ -z "${apptype}" ]] && apptype="Application"
  [[ -z "${categories}" ]] && categories="Utility;"

  file="${XDG_AUTOSTART}/${filename}.desktop"

  if [[ ! -e "${file}" ]]
  then
    touch ${file}
    TEMPLATE

    # Add entry information to the file
    PRINT ${_template} > ${file}

    PRINT "`SCRIPTNAME`: Created ${filename}!"
    exit 0
  else
    err "`SCRIPTNAME`: ${filename} already exists!"
    exit 1
  fi
}

editEntry() {
  filename="${1}"

  [[ -z "${filename}" ]] && read -p "Name of Entry: " filename

  file="${XDG_AUTOSTART}/${filename}.desktop"

  if [[ -e "${file}" ]]
  then
    ${EDITOR} ${file}
    PRINT "`SCRIPTNAME`: Edited ${filename}!"
    exit 0
  else
    err "`SCRIPTNAME`: Entry ${filename} does not exist!"
    exit 1
  fi
}

removeEntry() {
  filename="${1}"

  [[ -z "${filename}" ]] && read -p "Name of Entry: " filename

  file="${XDG_AUTOSTART}/${filename}.desktop"

  if [[ -e "${file}" ]]
  then
    rm -rf ${file}
    PRINT "`SCRIPTNAME`: Removed ${filename}!"
    exit 0
  else
    err "`SCRIPTNAME`: Entry ${filename} does not exist!"
    exit 1
  fi
}

listEntries() {
  ls -1 --group-directories-first ${XDG_AUTOSTART} | sed -e 's/\.desktop//'
  exit 0
}

printEntry() {
  filename="${1}"

  [[ -z "${filename}" ]] && read -p "Name of Entry: " filename

  file="${XDG_AUTOSTART}/${filename}.desktop"

  if [[ -e "${file}" ]]
  then
    PRINT 
    PRINT 
    cat ${file}
    exit 0
  else
    err "`SCRIPTNAME`: ${filename} does not exist!"
    exit 1
  fi
}

helpPrompt() {
  PRINT 
  PRINT "Manage XDG Autostart desktop entries."
  PRINT
  PRINT "Usage: `SCRIPTNAME` [command] [FLAGS]... [VALUES]..." 
  PRINT "Example: `SCRIPTNAME` c discord Discord /usr/bin/discord Internet"
  PRINT
  PRINT "Options: "
  PRINT "(c) create\t\tCreate an autostart entry and exit"
  PRINT "(e) edit\t\tEdit an autostart entry and exit"
  PRINT "(r) remove\t\tRemove an autostart entry and exit"
  PRINT "(l) list\t\tList all entries and exit"
  PRINT "(p) print\t\tDisplay an entry's contents and exit"
  PRINT
  PRINT "Create Arguments (in order)"
  PRINT "1. filename*\t\tThe file to work with (don't include .desktop)"
  PRINT "2. name*\t\tThe name of the app"
  PRINT "3. binary*\t\tThe executable that runs the app"
  PRINT "4. categories\t\tThe categories the app is in, seperated by semicolon"
  PRINT "5. icon\t\t\tThe icon for the app"
  PRINT "6. generic\t\tThe generic name of the app"
  PRINT "7. path\t\t\tThe path where the binary is housed, don't specify unless you know what you're doing"
  PRINT "8. type\t\t\tThe type of app, don't specify unless you know what you're doing"
  PRINT
  PRINT "Miscellaneous:"
  PRINT "(h) help\t\tDisplay this help and exit"
  PRINT "(v) version\t\tDisplay this script's version and exit"
  exit 0
}

# Creates the autostart directory if it does not already exist.
[[ ! -d "${XDG_AUTOSTART}" ]] && mkdir ${XDG_AUTOSTART}

cmd=`lowercase ${1}`

case "${cmd}" in
  c | create )
    makeEntry "${ARGS[@]}"
    ;;
  e | edit )
    editEntry "${2}"
    ;;
  r | remove )
    removeEntry "${2}"
    ;;
  l | list )
    listEntries
    ;;
  p | print )
    printEntry "${2}"
    ;;
  v | version )
    version
    ;;
  \? | h | help )
    helpPrompt
    ;;
  * )
    if [ -z "${cmd}" ]; then
      emptycmd
    else
      invalid "${1}"
    fi
    ;;
esac
