#!/usr/bin/env bash

##############################################
#	Author: Nidia Achrys
#	Project: tardis
#	Version: 1.0
#
#	Usage: tardis [command] [args]
#
#	Description:
#		This utility manages backups
##############################################

version='1.0'
author='Nidia Achrys'

# Source common script functions
source $SCRIPTS/libs/01-api.sh

#############
# Core Code #
#############

# Dependencies
api.required.command "nano"
api.required.command "rsync"

# Config
CONFDIR="${HOME}/.config/tardisrsync"
EXCLUSION_FILE="${CONFDIR}/exclusions.conf"
CONFIG="${CONFDIR}/default-disk.conf"

# Get the target directory and manifest file
tardis.target.get()
{
	if [ -f "${CONFIG}" ]; then

		# If the config file exists, get the directory specified from it and set it as the target.
		local text="$(cat ${CONFIG})"
		TARGET="`api.string.trim ${text}`"

	elif [ -n "${1}" ]; then
	
		# If the config file doesn't exist and the target is specified as an argument, use the argument.
		TARGET="${1}"
	
	fi

	# If the target directory exists, exit the script with an error message.
	[ ! -d "${TARGET}" ] && api.std.failMsg "That directory does not exist!"

	# Set the target to its absolute path
	TARGET="`readlink -f ${TARGET}`"

	# Set the manifest file path
	MANIFEST=${TARGET}/tardis-manifest.conf
	return 0
}

# Create a backup in the target
tardis.backups.create()
{
	# Generate the backup name based on the date/time
  	BACKUPNAME=$(date +"%Y-%m-%d_%H-%M-%S")

	# Create the manifest file if it doesn't exist
  	touch "${MANIFEST}"

	# Backup files not specified in the exclusion file, if it exists
	[ -f "${EXCLUSION_FILE}" ] && rsync -avhpru --exclude-from="${EXCLUSION_FILE}" --delete ${HOME} ${TARGET}
	
	# If the exclusions file doesn't exist, then backup all files in $HOME to the target directory.
	[ ! -f "${EXCLUSION_FILE}" ] && rsync -avhpru --delete ${HOME} ${TARGET}

	# Rename the backup directory to the timestamp
 	mv ${TARGET}/${USER} ${TARGET}/${BACKUPNAME}

	# Confirm the backup has finished
	api.std.logMsg "Finished backup!"

	# Print the backupname to the manifest file
	api.std.logMsg "${BACKUPNAME}" | tee -a ${MANIFEST}
	return 0
}

# Restore a backup from the target
tardis.backups.restore()
{
	BACKUPDIR="${TARGET}/${1}"

	# Check if the backup directory exists
	[ ! -d "${BACKUPDIR}" ] && api.std.failMsg "That backup does not exist!"

	# Restore all files/directories in the backup directory to $HOME
	for file in ${BACKUPDIR}/{.,}*
	do
		[ -d "${file}" ] && rsync --avhpru --delete "${file}" "${HOME}"
		[ -f "${file}" ] && rsync --avhpu --delete "${file}" "${HOME}"
	done

	# Confirm the restoration of the backup
	api.std.logMsg "'${BACKUPDIR}' restored."
	return 0
}

# Remove a backup
tardis.backups.remove()
{
	BACKUPDIR="${TARGET}/${1}"

	# Check if the backup directory exists
	[ ! -d "${BACKUPDIR}" ] && api.std.failMsg "That backup does not exist!"

	# Confirm whether to remove the backup
	read -p "Are you sure you want to remove this backup? (y/N) " confirmation
	
	# Make the confirmation text lowercase
	confirmation=`api.string.toLowerCase "${confirmation}"`

	# Remove the backup directory if the user chose 'y' or 'yes' at the prompt
	[ "${confirmation}" == "y" ] && rm -rf "${BACKUPDIR}" && return 0
	[ "${confirmation}" == "yes" ] && rm -rf "${BACKUPDIR}" && return 0

	# Cancel the removal of a backup if the user didn't choose 'y' or 'yes' at the prompt
	api.std.logMsg "Cancelling..."
	return 0
}

# List all the previous backups in the target
tardis.backups.list()
{
	# Array of all directories in the target (backups)
	FILES=${TARGET}/*/

	# Send error if no backup directories exist or if the manifest file is missing
	[ ! ${#FILES[@]} -gt 0 ] && api.std.errorMsg "There are no backups!" && return $?
	[ ! -f ${MANIFEST} ] && api.std.errorMsg "There are no backups!" && return $?

	# List all directories in the target
	ls -F ${TARGET} | grep /\$
	return 0
}

# Enable cron
tardis.settings.auto.enable()
{
	# Allow file and tab file
	local allow="/etc/cron.allow"
	local tab="/var/spool/cron/crontabs/${USER}"
	local lock="${TARGET}/.cron"
	
	# Create cron.allow, tab file, and lock file
	[ ! -f "${allow}" ] && sudo touch "${allow}"
	[ ! -f "${tab}" ] && sudo touch "${tab}"
	[ ! -f "${lock}" ] && touch "${lock}"

	# Check if the name of the user is in cron.allow, then add if it isn't
	local name="`cat ${allow} | grep ${USER}`"
	[ "${name}" != "${USER}" ] && api.std.printLn "${USER}" | sudo tee -a "${allow}"

	# Add entry to tab & lock file
	local entry="@daily ${HOME}/.local/bin/tardis backup"
	api.std.printLn "${entry}" | sudo tee -a "${tab}" >/dev/null 2>&1
	api.std.printLn "${entry}" | tee -a "${lock}" >/dev/null 2>&1

	return 0
}

# Disable Cron
tardis.settings.auto.disable()
{
	# Get the entry text and remove the cron lock
	local entry="`cat ${TARGET}/.cron`"
	rm -f "${TARGET}/.cron"

	# Tab file
	local tab="/var/spool/cron/crontabs/${USER}"

	# Remove the entry
	sudo sed -i "#${entry}#d" ${tab}
	# sudo cat ${tab} | sed "s|${entry}\n||g" | sudo tee ${tab}
	return 0
}

# Toggle Cron
tardis.settings.auto.toggle()
{
	if [ ! -f "${TARGET}/.cron" ]
	then
		tardis.settings.auto.enable
		api.std.logMsg "Automatic Backups Enabled"
	else
		tardis.settings.auto.disable
		api.std.logMsg "Automatic Backups Disabled"
	fi

	return $?
}

# Set the default disk to look for when not specified on the command line
tardis.settings.target.set()
{
	# Create config directory & file if it doesn't exist
	[ ! -d ${CONFDIR} ] && mkdir -p ${CONFDIR} && touch ${CONFIG}

	# Check if a directory was specified
	[ -z "${1}" ] && api.std.errorMsg "You must specify a directory to set as the default!" && return $?
	
	# Check if specified directory exists
	[ ! -d "${1}" ] && api.std.errorMsg "That is not a valid directory!" && return $?

	# Set the directory in the file
	api.std.printLn "${1}" > ${CONFIG}
	
	# Confirmation
	api.std.logMsg "Set a default target!"
	
	return 0
}

# Print the default target to STDOUT
tardis.settings.target.print()
{
	[ -f "${CONFIG}" ] && cat "${CONFIG}" && return 0 || api.std.errorMsg "There is no default target!" && return $?
}

# Edit the list of exclusions in $HOME/.config/tardisrsync/exclusions.conf
tardis.settings.exclusions.set()
{
	# Create config directory & file if it doesn't exist
	[ ! -d ${CONFDIR} ] && mkdir -p ${CONFDIR} && touch ${EXCLUSION_FILE}

	# Add all file/directory names to new exclusions file if it doesn't exist
	if [ ! -f "${EXCLUSION_FILE}" ]
	then

		for f in $HOME/{.,}*; do
			
			local name="`basename ${f}`"
			if [ "${name}" != '.' ] && [ "${name}" != '..' ]; then api.std.printLn "${name}" >> ${EXCLUSION_FILE}; fi
		
		done

		# Confirmation of the exclusion file's existence
		api.std.logMsg "Created exclusions file!"
	
	fi

	# Open the editor 
	[ -z "${EDITOR}" ] && nano ${EXCLUSION_FILE} || ${EDITOR} ${EXCLUSION_FILE}

	# Confirmation of the edited exclusions file
	api.std.logMsg "Exclusions edited!" && return 0
}

# Print the list of exclusions listed in $HOME/.config/tardisrsync/exclusions.conf
tardis.settings.exclusions.print()
{
	[ ! -e "${EXCLUSION_FILE}" ] && api.std.errorMsg "Exclusions have not been specified." && return $?
	cat ${EXCLUSION_FILE}
}

# Help Prompt
tardis.help()
{
	api.std.printLn
	api.std.printLn "Create, restore, and list backups."
	api.std.printLn 
	api.std.printLn "Usage: `api.script.name` [command] [args]"
	api.std.printLn "Example: `api.script.name` backup <disk path>"
	api.std.printLn 
	api.std.printLn "Commands"
	api.std.printLn "(b) backup\t\tCreate a backup"
	api.std.printLn "(r) restore\t\tRestore a backup"
	api.std.printLn "(d) delete\t\tDelete a backup"
	api.std.printLn "(l) list\t\tList all backups"
	api.std.printLn
	api.std.printLn "Settings"
	api.std.printLn "(a) toggle-automatic\tToggle automatic backups"
	api.std.printLn "(t) default-target\tSet a default target for future backups"
	api.std.printLn "(e) exclusions\t\tCreate or edit the exclusions file"
	api.std.printLn "(pt) print-target\tPrint the default target to the terminal"
	api.std.printLn "(pe) print-exclusions\tPrint out every excluded file/directory name"
	api.std.printLn 
	api.std.printLn "Miscellaneous"
	api.std.printLn "(h) help\t\tShow this prompt"
	api.std.printLn "(v) version\t\tPrint the version of this script"
	api.std.printLn
	return 0
}

# Make the command invocation lowercase
cmd=`api.string.toLowerCase ${1}`

# Command line options
case "${cmd}" in
	b | backup )
		tardis.target.get $2
		tardis.backups.create
    	;;
	r | restore)
		tardis.target.get $2
		tardis.backups.restore $3
		;;
	d | delete )
		tardis.target.get $2
		tardis.backups.remove
		;;
	l | list )
		tardis.target.get $2
		tardis.backups.list
		;;
	a | toggle-automatic )
		tardis.target.get $2
		tardis.settings.auto.toggle
		;;
	t | default-target )
		tardis.settings.target.set $2
		;;
	pt | print-target )
		tardis.settings.target.print
		;;
	e | exclusions )
		tardis.settings.exclusions.set
		;;
	pe | print-exclusions)
		tardis.settings.exclusions.print
		;;
	v | version )
		api.script.version
		;;
	\? | h | help )
		tardis.help
		;;
	* )
		[ -z "${cmd}" ] && tardis.help || api.errors.invalidCommand "${cmd}"
		;;
esac

# Exit the script with the last returned status code
exit $?
