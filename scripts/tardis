#!/usr/bin/env bash

##############################################
#	Author: Nidia Achrys
#	Project: tardis
#	Version: 1.0
#
#	Usage: tardis [command] [args]
#
#	Description:
#		This utility manages backups
##############################################

version='1.0'
author='Nidia Achrys'

#######################################################################
#							                Helper Functions						            #
#######################################################################

# Replacement for 'echo'
function PRINT()
{
	if [ -z "${1}" ]; then
		printf "\n"
	else
		printf "%b\n" "${1}"
	fi

	return 0
}

# Retrieve the name of the script file
function SCRIPTNAME()
{
	PRINT "${0##*/}"
	return 0
}

# Pauses script execution until the user presses ENTER
function pause()
{
	read -p "Press ENTER to continue..." cmd
	return 0
}

# Converts a string to all lowercase characters
function lowercase()
{
	printf "${1}" | tr "[:upper:]" "[:lower:]"
	return 0
}

# Error message for when an invalid command is used
function invalid()
{
	PRINT 
	PRINT "Invalid command \"${1}\". See \"`SCRIPTNAME` help\"."
	PRINT 
	return 1
}

# Error message for when no command is used
function emptycmd()
{
	PRINT 
	PRINT "You must specify a subcommand. See \"`SCRIPTNAME` help\"."
	PRINT 
	return 1
}

# Checks for a filename in $PATH (commands), if not found then exit with an error
function dependency()
{
	[[ ! `command -v ${1}` ]] && PRINT "'${1}' is required to run this program." && exit 1
}

# Prints the script name and version, as well as copyright, license notice, and 
# author name
function version()
{
	PRINT "`SCRIPTNAME` v${version}"
	PRINT "Copyright (C) `date +"%Y"` ${author}"
	PRINT "License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>."
	PRINT "This is free software: you are free to change and redistribute it."
	PRINT "There is NO WARRANTY, to the extent permitted by law."
	PRINT
	PRINT "Written by ${author}."
	return 0
}

#######################################################################
#								              Core Code							                  #
#######################################################################

# Dependencies
dependency "nano"
dependency "rsync"

# Config
CONFDIR="${HOME}/.config/tardisrsync"
EXCLUSION_FILE="${CONFDIR}/exclusions.conf"
CONFIG="${CONFDIR}/default-disk.conf"

# Get the target directory and manifest file
GETDIR()
{
  	[ -f "${CONFIG}" ] && BACKUPDISK=$(cat "${CONFIG}" | grep "DEFAULT_DISK=" | sed -e 's|DEFAULT_DISK=||')

  	if [ -n "${1}" ]; then
		TARGET="${1}"
	else
		[ -z "${BACKUPDISK}" ] && PRINT "You must specify a directory to back up or set a default!" && exit 1
		TARGET="${BACKUPDISK}"
	fi

	[ ! -d "${TARGET}" ] && PRINT "That directory does not exist!" && exit 1

	MANIFEST=${TARGET}/tardis-manifest.conf
	return 0
}

# Create a backup in the target
BACKUP()
{
	GETDIR $1
  	BACKUPNAME=$(date +"%Y-%m-%d_%H-%M-%S")

  	touch "${MANIFEST}"

	# HOME
	[ -f "${EXCLUSION_FILE}" ] && rsync -avhpru --exclude-from="${EXCLUSION_FILE}" --delete ${HOME} ${TARGET}
	[ ! -f "${EXCLUSION_FILE}" ] && rsync -avhpru --delete ${HOME} ${TARGET}

 	mv ${TARGET}/${USER} ${TARGET}/${BACKUPNAME}

	PRINT "Finished backup!"
	PRINT "[SUCCESSFUL] ${BACKUPNAME}" | tee -a ${MANIFEST}
	return 0
}

# Restore a backup from the target
RESTORE()
{
	GETDIR $1
	BACKUPDIR="${TARGET}/${2}"

	[ ! -d "${BACKUPDIR}" ] && PRINT "That backup does not exist!" && return 1

	for file in ${BACKUPDIR}/{.,}*
	do
		[ -d "${file}" ] && rsync --avhpru --delete "${file}" "${HOME}"
		[ -f "${file}" ] && rsync --avhpu --delete "${file}" "${HOME}"
	done

	PRINT "[SUCCESSFUL] '${BACKUPDIR}' restored."
	return 0
}

# Remove a backup
REMOVE()
{
	GETDIR
	BACKUPDIR="${TARGET}/${1}"

	[ ! -d "${BACKUPDIR}" ] && PRINT "That backup does not exist!" && exit 1

	read -p "Are you sure you want to remove this backup? (y/N) " confirmation
	confirmation=`lowercase "${confirmation}"`

	[ "${confirmation}" == "y" ] && rm -rf "${BACKUPDIR}" && return 0
	[ "${confirmation}" == "yes" ] && rm -rf "${BACKUPDIR}" && return 0

	PRINT "Cancelling..."
	return 0
}

# List all the previous backups in the target
LIST()
{
	GETDIR $1
	FILES=${TARGET}/*/

	[ ! ${#FILES[@]} -gt 0 ] && PRINT "There are no backups!" && return 1
	[ ! -f ${MANIFEST} ] && PRINT "There are no backups!" && return 1

	ls -F ${TARGET} | grep /\$
	return 0
}

# Set the default disk to look for when not specified on the command line
DEFAULT_TARGET()
{
	[ ! -d ${CONFDIR} ] && mkdir -p ${CONFDIR} && PRINT "Created config file!"
	[ -z "${1}" ] && PRINT "You must specify a directory to set as the default!" && return 1
	[ ! -d "${1}" ] && PRINT "That is not a valid directory!" && return 1

	cat ${CONFIG} | grep -iv "DEFAULT_DISK=" > ${CONFIG}
	PRINT "DEFAULT_DISK=${1}" >> ${CONFIG}
	PRINT "Set a default target!"
	return 0
}

# Edit the list of exclusions in $HOME/.config/tardisrsync/exclusions.conf
EXCLUSIONS()
{
	[ ! -d ${CONFDIR} ] && mkdir -p ${CONFDIR}
	[ ! -f ${EXCLUSION_FILE} ] && touch ${EXCLUSION_FILE} && PRINT "Created exclusions file!"

	[ -z "${EDITOR}" ] && nano ${EXCLUSION_FILE} || ${EDITOR} ${EXCLUSION_FILE}

	PRINT "Exclusions edited!" && return 0
}

# Print the list of exclusions listed in $HOME/.config/tardisrsync/exclusions.conf
PRINT_EXCLUSIONS()
{
	[ ! -e "${EXCLUSION_FILE}" ] && PRINT "Exclusions have not been specified." && return 1
	cat ${EXCLUSION_FILE}
}

# Help Prompt
help_prompt()
{
	PRINT
	PRINT "Create, restore, and list backups."
	PRINT 
	PRINT "Usage: `SCRIPTNAME` [command] [args]"
	PRINT "Example: `SCRIPTNAME` backup <disk path>"
	PRINT 
	PRINT "Commands"
	PRINT "(b) backup\t\tCreate a backup"
	PRINT "(r) restore\t\tRestore a backup"
	PRINT "(d) delete\t\tDelete a backup"
	PRINT "(l) list\t\tList all backups"
	PRINT
	PRINT "Settings"
	PRINT "(t) default-target\tSet a default target for future backups"
	PRINT "(e) exclusions\t\tCreate or edit the exclusions file"
	PRINT "(p) print-exclusions\tPrint out every excluded file/directory name"
	PRINT 
	PRINT "Miscellaneous"
	PRINT "(h) help\t\tShow this prompt"
	PRINT "(v) version\t\tPrint the version of this script"
	return 0
}

cmd=`lowercase ${1}`

# Command line options
case "${cmd}" in
	b | backup )
		BACKUP $2
    	;;
	r | restore)
		RESTORE $2 $3
		;;
	d | delete )
		REMOVE $2
		;;
	l | list )
		LIST $2
		;;
	t | default-target )
		DEFAULT_TARGET $2
		;;
	e | exclusions )
		EXCLUSIONS
		;;
	p | print-exclusions)
		PRINT_EXCLUSIONS
		;;
	v | version )
		version
		;;
	\? | h | help )
		help_prompt
		;;
	* )
		[ -z "${cmd}" ] && help_prompt || invalid "${cmd}"
		;;
esac

# Exit the script with the last returned status code
exit $?
