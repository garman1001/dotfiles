#!/usr/bin/env bash

##############################################
#	Author: Nidia Achrys
#	Project: tardis
#	Version: 1.0
#
#	Usage: tardis [command] [args]
#
#	Description:
#		This utility manages backups
##############################################

version='1.0'
author='Nidia Achrys'

# Source common script functions
source $SCRIPTS/01-api.sh

#############
# Core Code #
#############

# Dependencies
DEPENDENCY "nano"
DEPENDENCY "rsync"

# Config
CONFDIR="${HOME}/.config/tardisrsync"
EXCLUSION_FILE="${CONFDIR}/exclusions.conf"
CONFIG="${CONFDIR}/default-disk.conf"

# Get the target directory and manifest file
getTarget()
{
	if [ -f "${CONFIG}" ]; then

		# If the config file exists, get the directory specified from it and set it as the target.
		local text="$(cat ${CONFIG})"
		TARGET="`TRIM ${text}`"

	elif [ -n "${1}" ]; then
	
		# If the config file doesn't exist and the target is specified as an argument, use the argument.
		TARGET="${1}"
	
	fi

	# If the target directory exists, exit the script with an error message.
	[ ! -d "${TARGET}" ] && FAIL "That directory does not exist!"

	# Set the target to its absolute path
	TARGET="`readlink -f ${TARGET}`"

	# Set the manifest file path
	MANIFEST=${TARGET}/tardis-manifest.conf
	return 0
}

# Create a backup in the target
backupFiles()
{
	# Generate the backup name based on the date/time
  	BACKUPNAME=$(date +"%Y-%m-%d_%H-%M-%S")

	# Create the manifest file if it doesn't exist
  	touch "${MANIFEST}"

	# Backup files not specified in the exclusion file, if it exists
	[ -f "${EXCLUSION_FILE}" ] && rsync -avhpru --exclude-from="${EXCLUSION_FILE}" --delete ${HOME} ${TARGET}
	
	# If the exclusions file doesn't exist, then backup all files in $HOME to the target directory.
	[ ! -f "${EXCLUSION_FILE}" ] && rsync -avhpru --delete ${HOME} ${TARGET}

	# Rename the backup directory to the timestamp
 	mv ${TARGET}/${USER} ${TARGET}/${BACKUPNAME}

	# Confirm the backup has finished
	PRINT "Tardis: Finished backup!"

	# Print the backupname to the manifest file
	PRINT "Tardis:  ${BACKUPNAME}" | tee -a ${MANIFEST}
	return 0
}

# Restore a backup from the target
restoreFiles()
{
	BACKUPDIR="${TARGET}/${1}"

	# Check if the backup directory exists
	[ ! -d "${BACKUPDIR}" ] && FAIL "That backup does not exist!"

	# Restore all files/directories in the backup directory to $HOME
	for file in ${BACKUPDIR}/{.,}*
	do
		[ -d "${file}" ] && rsync --avhpru --delete "${file}" "${HOME}"
		[ -f "${file}" ] && rsync --avhpu --delete "${file}" "${HOME}"
	done

	# Confirm the restoration of the backup
	LOG "'${BACKUPDIR}' restored."
	return 0
}

# Remove a backup
removeBackup()
{
	BACKUPDIR="${TARGET}/${1}"

	# Check if the backup directory exists
	[ ! -d "${BACKUPDIR}" ] && FAIL "That backup does not exist!"

	# Confirm whether to remove the backup
	read -p "Are you sure you want to remove this backup? (y/N) " confirmation
	
	# Make the confirmation text lowercase
	confirmation=`LOWERCASE "${confirmation}"`

	# Remove the backup directory if the user chose 'y' or 'yes' at the prompt
	[ "${confirmation}" == "y" ] && rm -rf "${BACKUPDIR}" && return 0
	[ "${confirmation}" == "yes" ] && rm -rf "${BACKUPDIR}" && return 0

	# Cancel the removal of a backup if the user didn't choose 'y' or 'yes' at the prompt
	LOG "Cancelling..."
	return 0
}

# List all the previous backups in the target
listBackups()
{
	# Array of all directories in the target (backups)
	FILES=${TARGET}/*/

	# Send error if no backup directories exist or if the manifest file is missing
	[ ! ${#FILES[@]} -gt 0 ] && ERROR "There are no backups!" && return $?
	[ ! -f ${MANIFEST} ] && ERROR "There are no backups!" && return $?

	# List all directories in the target
	ls -F ${TARGET} | grep /\$
	return 0
}

# Enable cron
enableAutoBackups()
{
	# Allow file and tab file
	local allow="/etc/cron.allow"
	local tab="/var/spool/cron/crontabs/${USER}"
	local lock="${TARGET}/.cron"
	
	# Create cron.allow, tab file, and lock file
	[ ! -f "${allow}" ] && sudo touch "${allow}"
	[ ! -f "${tab}" ] && sudo touch "${tab}"
	[ ! -f "${lock}" ] && touch "${lock}"

	# Check if the name of the user is in cron.allow, then add if it isn't
	local name="`cat ${allow} | grep ${USER}`"
	[ "${name}" != "${USER}" ] && PRINT "${USER}" | sudo tee -a "${allow}"

	# Add entry to tab & lock file
	local entry="@daily ${HOME}/.local/bin/tardis backup"
	PRINT "${entry}" | sudo tee -a "${tab}" >/dev/null 2>&1
	PRINT "${entry}" | tee -a "${lock}" >/dev/null 2>&1

	return 0
}

# Disable Cron
disableAutoBackups()
{
	# Get the entry text and remove the cron lock
	local entry="`cat ${TARGET}/.cron`"
	rm -f "${TARGET}/.cron"

	# Tab file
	local tab="/var/spool/cron/crontabs/${USER}"

	# Remove the entry
	sudo sed -i "#${entry}#d" ${tab}
	# sudo cat ${tab} | sed "s|${entry}\n||g" | sudo tee ${tab}
	return 0
}

# Toggle Cron
toggleAutoBackups()
{
	if [ ! -f "${TARGET}/.cron" ]
	then
		enableAutoBackups
		LOG "Automatic Backups Enabled"
	else
		disableAutoBackups
		LOG "Automatic Backups Disabled"
	fi

	return $?
}

# Set the default disk to look for when not specified on the command line
setDefaultTarget()
{
	# Create config directory & file if it doesn't exist
	[ ! -d ${CONFDIR} ] && mkdir -p ${CONFDIR} && touch ${CONFIG}

	# Check if a directory was specified
	[ -z "${1}" ] && ERROR "You must specify a directory to set as the default!" && return $?
	
	# Check if specified directory exists
	[ ! -d "${1}" ] && ERROR "That is not a valid directory!" && return $?

	# Set the directory in the file
	PRINT "${1}" > ${CONFIG}
	
	# Confirmation
	LOG "Set a default target!"
	
	return 0
}

# Print the default target to STDOUT
printDefaultTarget()
{
	[ -f "${CONFIG}" ] && cat "${CONFIG}" && return 0 || ERROR "There is no default target!" && return $?
}

# Edit the list of exclusions in $HOME/.config/tardisrsync/exclusions.conf
setExclusions()
{
	# Create config directory & file if it doesn't exist
	[ ! -d ${CONFDIR} ] && mkdir -p ${CONFDIR} && touch ${EXCLUSION_FILE}

	# Add all file/directory names to new exclusions file if it doesn't exist
	if [ ! -f "${EXCLUSION_FILE}" ]
	then

		for f in $HOME/{.,}*; do
			
			local name="`basename ${f}`"
			if [ "${name}" != '.' ] && [ "${name}" != '..' ]; then PRINT "${name}" >> ${EXCLUSION_FILE}; fi
		
		done

		# Confirmation of the exclusion file's existence
		LOG "Created exclusions file!"
	
	fi

	# Open the editor 
	[ -z "${EDITOR}" ] && nano ${EXCLUSION_FILE} || ${EDITOR} ${EXCLUSION_FILE}

	# Confirmation of the edited exclusions file
	LOG "Exclusions edited!" && return 0
}

# Print the list of exclusions listed in $HOME/.config/tardisrsync/exclusions.conf
printExclusions()
{
	[ ! -e "${EXCLUSION_FILE}" ] && ERROR "Exclusions have not been specified." && return $?
	cat ${EXCLUSION_FILE}
}

# Help Prompt
helpPrompt()
{
	PRINT
	PRINT "Create, restore, and list backups."
	PRINT 
	PRINT "Usage: `SCRIPTNAME` [command] [args]"
	PRINT "Example: `SCRIPTNAME` backup <disk path>"
	PRINT 
	PRINT "Commands"
	PRINT "(b) backup\t\tCreate a backup"
	PRINT "(r) restore\t\tRestore a backup"
	PRINT "(d) delete\t\tDelete a backup"
	PRINT "(l) list\t\tList all backups"
	PRINT
	PRINT "Settings"
	PRINT "(a) toggle-automatic\tToggle automatic backups"
	PRINT "(t) default-target\tSet a default target for future backups"
	PRINT "(e) exclusions\t\tCreate or edit the exclusions file"
	PRINT "(pt) print-target\tPrint the default target to the terminal"
	PRINT "(pe) print-exclusions\tPrint out every excluded file/directory name"
	PRINT 
	PRINT "Miscellaneous"
	PRINT "(h) help\t\tShow this prompt"
	PRINT "(v) version\t\tPrint the version of this script"
	PRINT
	return 0
}

# Make the command invocation lowercase
cmd=`LOWERCASE ${1}`

# Command line options
case "${cmd}" in
	b | backup )
		getTarget $2
		backupFiles
    	;;
	r | restore)
		getTarget $2
		restoreFiles $3
		;;
	d | delete )
		getTarget $2
		removeBackup
		;;
	l | list )
		getTarget $2
		listBackups
		;;
	a | toggle-automatic )
		getTarget $2
		toggleAutoBackups
		;;
	t | default-target )
		setDefaultTarget $2
		;;
	pt | print-target )
		printDefaultTarget
		;;
	e | exclusions )
		setExclusions
		;;
	pe | print-exclusions)
		printExclusions
		;;
	v | version )
		VERSION
		;;
	\? | h | help )
		helpPrompt
		;;
	* )
		[ -z "${cmd}" ] && helpPrompt || INVALID "${cmd}"
		;;
esac

# Exit the script with the last returned status code
exit $?
