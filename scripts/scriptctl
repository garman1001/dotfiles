#!/usr/bin/env bash

##############################################
#	Author: Nidia Achrys
#	Project: scriptctl
#	Version: 1.0
#
#	Usage: scriptctl [command] [args]
#
#	Description:
#		This utility provides tools to create, edit, list,
#		and print shell scripts.
##############################################

version='1.0'
author='Nidia Achrys'

# Source common script functions
source $SCRIPTS/libs/01-api.sh

#############
# Core Code #
#############

api.required.command "nano"

# Set the scripts directory to $HOME/.local/bin if not already set
[[ -z "${SCRIPTS}" ]] && SCRIPTS="$HOME/.local/bin"

# If EDITOR is empty, or the specified EDITOR does not exist, use nano
[[ -z "${EDITOR}" ]] && EDITOR=nano
[[ `command -v ${EDITOR}` ]] || EDITOR=nano

# Script template string generator
function TEMPLATE()
{
_template="#!/usr/bin/env ${default_shell:=bash}

##############################################
#	Author: ${author_name:=Some Random Scripter}
#	Project: ${scriptname}
#	Version: 1.0
#
#	Usage: ${scriptname} [command] [args]
#
#	Description:
#		${description:=Blah Blah Blah}
##############################################

version='1.0'
author=''

# Source common script functions
source \$SCRIPTS/libs/01-api.sh

#############
# Core Code #
#############

# This is where you put your script's functions, variables, logic, etc.

"
}

# Get the name of the script to manage
function getName()
{

    if [[ -z "${1}" ]]
    then

		# Prompt for a script name if one wasn't provided in the command line
        read -p "Enter the name of the script: " scriptname

	else

		# Set the script name to the first command line argument if one was provided.
		scriptname="${1}"

    fi

	# Set the script path
    script="${SCRIPTS}/${scriptname}"
    return 0
}

# Prompt for basic script information and create it
function createScript()
{
	getName "${1}"

	# Prompt for script information
	read -p "Shell Name > " default_shell
	read -p "Author Name > " author_name
	read -p "Description > " description

	# Generate the template
	TEMPLATE

    if [[ ! -f "${script}" ]]
    then

		# Create the script if it doesn't exist
    	touch ${script}

		# Print the template string to the script
    	api.std.printLn "${_template}" > ${script}
    	
		# Edit the script
		${EDITOR} ${script}

		# Make the script executable
    	chmod +x ${script}
    	
		# Confirmation log
		api.std.logMsg "${scriptname} created!"
    	return 0
    
	else
    
		# Fail if script exists
		api.std.failMsg "${scriptname} already exists!"
    
	fi
}

# Edit the contents of a script
function editScript()
{
	getName "${1}"

	if [[ -f "${script}" ]]
	then
	
		# Edit the script if it exists
		${EDITOR} ${script}

		# Confirmation
		api.std.logMsg "${scriptname} edited!"
		
		return 0
	
	else
	
		# Error that the script doesn't exist
		api.std.errorMsg "${scriptname} does not exist!"
		
		# Ask if the script should be created
		read -p "Create script? Y\n: " answer

		# Create the script if the answer to the prompt was 'y' or 'yes'
		answer=`api.string.toLowerCase "${answer}"`
		[ "${answer}" = "y" ] && createScript ${scriptname} || return 1
	
	fi
}

# Delete a script
function removeScript()
{
	getName "${1}"

	if [[ -f "${script}" ]]
	then

		# Remove the script if it exists
		rm -f ${script}

		# Confirmation
		api.std.logMsg "${scriptname} removed!"
		return 0

	else

		# Fail if the script doesn't exist
		api.std.failMsg "${scriptname} does not exist!"
		return 1

	fi
}

# Rename a script
function renameScript()
{
	getName "${1}"

	# Get the new name from the second command line argument
	newName="${2}"

	# Generate the new path based on the new name
	newPath="${SCRIPTS}/${newName}"

	# If the script exists and the newName string isn't empty:
	if [ -f "${script}" ] && [ ! -z "${newName}" ]
	then

		# Rename the script
		mv "${script}" "${SCRIPTS}/${newName}"

		# Confirmation
		api.std.logMsg "Renamed '${script##*/}' to '${newName}'."
		return 0

	# If the newName string is empty:
	elif [ -z "${newName}" ]
	then

		# Prompt for a new name
		read -p "What do you want the script to be called?" newName

		# Rename the script
		mv "${script}" "${SCRIPTS}/${newName}"

		# Confirmation
		api.std.logMsg "Renamed '${script##*/}' to '${newName}'."
		return 0

	# If the script doesn't exist:
	elif [ ! -f "${script}" ]
	then

		# Fail
		api.std.failMsg "Script '${script##*/}' does not exist!"
		return 1

	fi
}

# Print the script to the command line
function printScript()
{
	getName "${1}"

	# If the script exists
	if [[ -f "${script}" ]]
	then
		
		# Print out the script
		cat ${script}
		return 0
	
	# If the script doesn't exist:
	else
	
		# Fail
		api.std.failMsg "${scriptname} does not exist!"
		return 1
	
	fi
}

# List all files in the scripts directory
function listScripts()
{
	find $SCRIPTS/ -maxdepth 1 -type f -executable -exec basename {} \;
	return 0
}

# Help prompt
function helpPrompt()
{
	api.std.printLn "Create, edit, remove, or print scripts."
	api.std.printLn 
	api.std.printLn "Usage: `api.script.name` [command] [args]"
	api.std.printLn "Example: `api.script.name` create torrentctl"
	api.std.printLn 
	api.std.printLn "Commands:"
	api.std.printLn "(c) create\t\tCreate a new script"
	api.std.printLn "(e) edit\t\tEdit an existing script"
	api.std.printLn "(r) rename\t\tRename an existing script"
	api.std.printLn "(d) delete\t\tDelete an existing script"
	api.std.printLn "(p) print\t\tPrint a script to STDOUT"
	api.std.printLn "(l) list\t\tList all scripts"
	api.std.printLn 
	api.std.printLn "Miscellaneous:"
	api.std.printLn "(h) help\t\tdisplay this help and exit"
	api.std.printLn "(v) version\t\toutput version information and exit"
	return 0
}

# Create the scripts directory if it does not already exist.
[[ ! -d "${SCRIPTS}" ]] && mkdir ${SCRIPTS}

# Set the subcommand to lowercase
cmd=`api.string.toLowerCase ${1}`

case "${cmd}" in
	c | create )
		createScript "${2}" "${3}"
		;;
	e | edit )
		editScript "${2}"
		;;
	r | rename )
		renameScript "${2}" "${3}"
		;;
	d | delete )
		removeScript "${2}"
		;;
	p | print )
		printScript "${2}"
		;;
	l | list )
		listScripts
		;;
	v | version )
		api.script.version
		;;
	\? | h | help )
		helpPrompt
		;;
	* )
		[ -z "${cmd}" ] && helpPrompt || api.errors.invalidCommand "${cmd}"
		;;
esac

# Exit the script with the last returned status code
exit $?
