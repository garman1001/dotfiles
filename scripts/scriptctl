#!/usr/bin/env bash

##############################################
#	Author: Nidia Achrys
#	Project: scriptctl
#	Version: 1.0
#
#	Usage: scriptctl [command] [args]
#
#	Description:
#		This utility provides tools to create, edit, list,
#		and print shell scripts.
##############################################

version='1.0'
author='Nidia Achrys'

#######################################################################
#							                Helper Functions						            #
#######################################################################

# Replacement for 'echo'
function PRINT()
{
	if [ -z "${1}" ]; then
		printf "\n"
	else
		printf "%b\n" "${1}"
	fi

	return 0
}

# Retrieve the name of the script file
function SCRIPTNAME()
{
	PRINT "${0##*/}"
	return 0
}

# Pauses script execution until the user presses ENTER
function pause()
{
	read -p "Press ENTER to continue..." cmd
	return 0
}

# Converts a string to all lowercase characters
function lowercase()
{
	printf "${1}" | tr "[:upper:]" "[:lower:]"
	return 0
}

# Error message for when an invalid command is used
function invalid()
{
	PRINT 
	PRINT "Invalid command \"${1}\". See \"`SCRIPTNAME` help\"."
	PRINT 
	return 1
}

# Error message for when no command is used
function emptycmd()
{
	PRINT 
	PRINT "You must specify a subcommand. See \"`SCRIPTNAME` help\"."
	PRINT 
	return 1
}

# Checks for a filename in $PATH (commands), if not found then exit with an error
function dependency()
{
	[[ ! `command -v ${1}` ]] && PRINT "'${1}' is required to run this program." && exit 1
}

# Checks to see if the script is being run as root, and if not then exit.
function requireRoot()
{
	if [[ $EUID -ne 0 ]]
	then
		PRINT "This script must be run as root" 1>&2
		exit 1
	fi
}

# Prints the script name and version, as well as copyright, license notice, and 
# author name
function version()
{
	PRINT "`SCRIPTNAME` v${version}"
	PRINT "Copyright (C) `date +"%Y"` ${author}"
	PRINT "License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>."
	PRINT "This is free software: you are free to change and redistribute it."
	PRINT "There is NO WARRANTY, to the extent permitted by law."
	PRINT
	PRINT "Written by ${author}."
	return 0
}

#######################################################################
#								              Core Code							                  #
#######################################################################

dependency "nano"

default_shell="bash"

[[ -z "${SCRIPTS}" ]] && SCRIPTS="$HOME/.local/bin"

# If EDITOR is empty, or the EDITOR does not exist, use nano
[[ -z "${EDITOR}" ]] && EDITOR=nano
[[ `command -v ${EDITOR}` ]] || EDITOR=nano

# Functions

function TEMPLATE()
{
_template="#!/usr/bin/env ${default_shell}

##############################################
#	Author: <your name here>
#	Project: ${scriptname}
#	Version: 1.0
#
#	Usage: ${scriptname} [command] [args]
#
#	Description:
#		Change this
##############################################

version='1.0'
author=''

#######################################################################
#							Helper Functions						  #
#######################################################################

# Replacement for 'echo'
function PRINT()
{
	if [ -z \"\${1}\" ]; then
		printf \"\\\n\"
	else
		printf \"%b\\\n\" \"\${1}\"
	fi
	return 0
}

# Retrieve the name of the script file
function SCRIPTNAME()
{
	PRINT \"\${0##*/}\"
	return 0
}

# Pauses script execution until the user presses ENTER
function pause()
{
	read -p \"Press ENTER to continue...\" cmd
	return 0
}

# Converts a string to all lowercase characters
function lowercase()
{
	printf \"\${1}\" | tr \"[:upper:]\" \"[:lower:]\"
	return 0
}

# Error message for when an invalid command is used
function invalid()
{
	PRINT 
	PRINT \"Invalid command \\\"\${1}\\\". See \\\"\`SCRIPTNAME\` help\\\".\"
	PRINT 
	return 1
}

# Error message for when no command is used
function emptycmd()
{
	PRINT 
	PRINT \"You must specify a subcommand. See \\\"\`SCRIPTNAME\` help\\\".\"
	PRINT 
	return 1
}

# Checks for a filename in \$PATH (commands), if not found then exit with an error
function dependency()
{
	[[ ! \`command -v \${1}\` ]] && PRINT \"'\${1}' is required to run this program.\" && exit 1
}

# Checks to see if the script is being run as root, and if not then exit.
function requireRoot()
{
	if [[ \$EUID -ne 0 ]]
	then
		PRINT \"This script must be run as root\" 1>&2
		exit 1
	fi
}

# Prints the script name and version, as well as copyright, license notice, and 
# author name
function version()
{
	PRINT \"\`SCRIPTNAME\` v\${version}\"
	PRINT \"Copyright (C) \`date +\"%Y\"\` \${author}\"
	PRINT \"License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\"
	PRINT \"This is free software: you are free to change and redistribute it.\"
	PRINT \"There is NO WARRANTY, to the extent permitted by law.\"
	PRINT
	PRINT \"Written by \${author}.\"
	return 0
}

#######################################################################
#								Core Code							  #
#######################################################################

# This is where you put your script's functions, variables, logic, etc.

"
}

function getName()
{
    if [[ -z "${1}" ]]
    then
        read -p "Enter the name of the script: " scriptname
	else
		scriptname="${1}"
    fi
    script="${SCRIPTS}/${scriptname}"
    return 0
}

function createScript()
{
	getName "${1}"

	[ -n "${2}" ] && default_shell="${2}"
	TEMPLATE

    if [[ ! -e "${script}" ]]
    then
    	touch ${script}
    	PRINT "${_template}" > ${script}
    	
		${EDITOR} ${script}
    	chmod +x ${script}
    	
		PRINT "`SCRIPTNAME`: ${scriptname} created!"
    	return 0
    else
    	PRINT "`SCRIPTNAME`: ${scriptname} already exists!"
    	return 1
    fi
}

function editScript()
{
	getName "${1}"

	if [[ -e "${script}" ]]
	then
		${EDITOR} ${script}
		PRINT "`SCRIPTNAME`: ${scriptname} edited!"
		
		return 0
	else
		PRINT "`SCRIPTNAME`: ${scriptname} does not exist!"
		read -p "Create script? Y\n: " answer

		answer=`lowercase "${answer}"`
		[ "${answer}" = "y" ] && createScript || return 1
	fi
}

function removeScript()
{
	getName "${1}"

	if [[ -e "${script}" ]]
	then
		rm -f ${script}
		PRINT "`SCRIPTNAME`: ${scriptname} removed!"
		return 0
	else
		PRINT "`SCRIPTNAME`: ${scriptname} does not exist!"
		return 1
	fi
}

function renameScript()
{
	getName "${1}"

	newName="${2}"
	newPath="${SCRIPTS}/${newName}"

	if [ -f "${script}" ] && [ ! -z "${newName}" ]
	then

		mv "${script}" "${SCRIPTS}/${newName}"

		PRINT "`SCRIPTNAME`: Renamed '${script##*/}' to '${newName}'."
		return 0

	elif [ -z "${newName}" ]
	then

		read -p "What do you want the script to be called?" newName
		mv "${script}" "${SCRIPTS}/${newName}"

		PRINT "`SCRIPTNAME`: Renamed '${script##*/}' to '${newName}'."
		return 0

	elif [ ! -f "${script}" ]
	then

		PRINT "Script '${script##*/}' does not exist!"
		return 1

	fi
}

function printScript()
{
	getName "${1}"

	if [[ -e "${script}" ]]
	then
		cat ${script}
		return 0
	else
		PRINT "`SCRIPTNAME`: ${scriptname} does not exist!"
		return 1
	fi
}

function listScripts()
{
	ls -1 --color=auto $SCRIPTS
	return 0
}

function helpPrompt()
{
	PRINT "Create, edit, remove, or print scripts."
	PRINT 
	PRINT "Usage: `SCRIPTNAME` [command] [args]"
	PRINT "Example: `SCRIPTNAME` create torrentctl zsh"
	PRINT 
	PRINT "Commands:"
	PRINT "(c) create\t\tCreate a new script"
	PRINT "(e) edit\t\tEdit an existing script"
	PRINT "(r) rename\t\tRename an existing script"
	PRINT "(d) delete\t\tDelete an existing script"
	PRINT "(p) print\t\tPrint a script to STDOUT"
	PRINT "(l) list\t\tList all scripts"
	PRINT 
	PRINT "Miscellaneous:"
	PRINT "(h) help\t\tdisplay this help and exit"
	PRINT "(v) version\t\toutput version information and exit"
	return 0
}

# Create the scripts directory if it does not already exist.
[[ ! -d "${SCRIPTS}" ]] && mkdir ${SCRIPTS}

cmd=`lowercase ${1}`

case "${cmd}" in
	c | create )
		createScript "${2}" "${3}"
		;;
	e | edit )
		editScript "${2}"
		;;
	r | rename )
		renameScript "${2}" "${3}"
		;;
	d | delete )
		removeScript "${2}"
		;;
	p | print )
		printScript "${2}"
		;;
	l | list )
		listScripts
		;;
	v | version )
		version
		;;
	\? | h | help )
		helpPrompt
		;;
	* )
		[ -z "${cmd}" ] && helpPrompt || invalid "${cmd}"
		;;
esac

# Exit the script with the last returned status code
exit $?
