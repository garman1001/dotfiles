#!/usr/bin/env bash

##############################################
#	Author: Nidia Achrys
#	Project: scriptctl
#	Version: 1.0
#
#	Usage: scriptctl [command] [args]
#
#	Description:
#		This utility provides tools to create, edit, list,
#		and print shell scripts.
##############################################

# Source common script functions
source $SCRIPTS/libs/01-api.sh

#############
# Help Menu #
#############

api.script.author "Nidia Achrys"
api.script.setVersion "1.0"

# Description/usage/examples
api.script.description "Create, edit, remove, or print scripts."
api.script.usage "[command] [args]"
api.script.example "create torrentctl"
api.script.example "list"

# CLI Commands
api.script.option "c" "create" "Create a new script"
api.script.option "e" "edit" "Edit an existing script"
api.script.option "r" "rename" "Rename an existing script"
api.script.option "d" "delete" "Delete an existing script"
api.script.option "p" "print" "Print a script to the terminal"
api.script.option "l" "list" "List all scripts"

#############
# Core Code #
#############

api.required.command "nano"

# Set the scripts directory to $HOME/.local/bin if not already set
[[ -z "${SCRIPTS}" ]] && SCRIPTS="$HOME/.local/bin"

# If EDITOR is empty, or the specified EDITOR does not exist, use nano
[[ -z "${EDITOR}" ]] && EDITOR=nano
[[ `command -v ${EDITOR}` ]] || EDITOR=nano

# Script template string generator
scriptctl.template.generate ()
{
_template="#!/usr/bin/env ${default_shell:=bash}

##############################################
#	Author: ${author_name:=Some Random Scripter}
#	Project: ${scriptname}
#	Version: 1.0
#
#	Usage: ${scriptname} [command] [args]
#
#	Description:
#		${description:=Blah Blah Blah}
##############################################

# Source common script functions
source \$SCRIPTS/libs/01-api.sh

#############
# Help Menu #
#############

api.script.author \"${author_name:=Some Random Scripter}\"
api.script.setVersion \"1.0\"

# Description/usage/examples
api.script.description \"\"
api.script.usage \"\"
api.script.example \"\"

# CLI Commands
api.script.option \"\" \"\" \"\"

# CLI Settings Commands
api.script.setting \"\" \"\" \"\"

#############
# Core Code #
#############

# This is where you put your script's functions, variables, logic, etc.

"

# Add the CLI handler to the template if the variable is true
if [ "${includeCliHandler}" == "true" ]
then
_template="${_template}
###############
# CLI Handler #
###############

cmd=\"\$(api.string.toLowerCase \${1})\"

case \"\${cmd}\" in
	v | version )
		api.script.version
		;;
	\? | h | help )
		api.script.help
		;;
	* )
		[ -z \"\${cmd}\" ] && api.script.help || api.errors.invalidCommand \"\${1}\"
		;;
esac
"
fi

}

# Get the name of the script to manage
scriptctl.script.getName ()
{

    if [[ -z "${1}" ]]
    then

		# Prompt for a script name if one wasn't provided in the command line
        read -p "Script Name > " scriptname

	else

		# Set the script name to the first command line argument if one was provided.
		scriptname="${1}"

    fi

	# Set the script path
    script="${SCRIPTS}/${scriptname}"
    return 0
}

# Prompt for basic script information and create it
scriptctl.script.create ()
{
	scriptctl.script.getName "${1}"

	# Prompt for script information
	read -p "Shell Name > " default_shell
	read -p "CLI handler (y/N) " includeHandler
	read -p "Author Name > " author_name
	read -p "Description > " description

	# Determine whether to include the cli handler in the template
	includeHandler="$(api.string.toLowerCase ${includeHandler})"
	case "${includeHandler}" in

		y | yes ) includeCliHandler="true"
	
	esac

	# Generate the template
	scriptctl.template.generate

    if [[ ! -f "${script}" ]]
    then

		# Create the script if it doesn't exist
    	touch ${script}

		# Print the template string to the script
    	api.std.printLn "${_template}" > ${script}
    	
		# Edit the script
		${EDITOR} ${script}

		# Make the script executable
    	chmod +x ${script}
    	
		# Confirmation log
		api.std.logMsg "${scriptname} created!"
    	return 0
    
	else
    
		# Fail if script exists
		api.std.failMsg "${scriptname} already exists!"
    
	fi
}

# Edit the contents of a script
scriptctl.script.edit ()
{
	scriptctl.script.getName "${1}"

	if [[ -f "${script}" ]]
	then
	
		# Edit the script if it exists
		${EDITOR} ${script}

		# Confirmation
		api.std.logMsg "${scriptname} edited!"
		
		return 0
	
	else
	
		# Error that the script doesn't exist
		api.std.errorMsg "${scriptname} does not exist!"
		
		# Ask if the script should be created
		read -p "Create script? Y\n: " answer

		# Create the script if the answer to the prompt was 'y' or 'yes'
		answer=`api.string.toLowerCase "${answer}"`
		[ "${answer}" = "y" ] && scriptctl.script.create ${scriptname} || return 1
	
	fi
}

# Delete a script
scriptctl.script.delete ()
{
	scriptctl.script.getName "${1}"

	if [[ -f "${script}" ]]
	then

		# Remove the script if it exists
		rm -f ${script}

		# Confirmation
		api.std.logMsg "${scriptname} removed!"
		return 0

	else

		# Fail if the script doesn't exist
		api.std.failMsg "${scriptname} does not exist!"
		return 1

	fi
}

# Rename a script
scriptctl.script.rename ()
{
	scriptctl.script.getName "${1}"

	# Get the new name from the second command line argument
	newName="${2}"

	# Generate the new path based on the new name
	newPath="${SCRIPTS}/${newName}"

	# If the script exists and the newName string isn't empty:
	if [ -f "${script}" ] && [ ! -z "${newName}" ]
	then

		# Rename the script
		mv "${script}" "${SCRIPTS}/${newName}"

		# Confirmation
		api.std.logMsg "Renamed '${script##*/}' to '${newName}'."
		return 0

	# If the newName string is empty:
	elif [ -z "${newName}" ]
	then

		# Prompt for a new name
		read -p "What do you want the script to be called?" newName

		# Rename the script
		mv "${script}" "${SCRIPTS}/${newName}"

		# Confirmation
		api.std.logMsg "Renamed '${script##*/}' to '${newName}'."
		return 0

	# If the script doesn't exist:
	elif [ ! -f "${script}" ]
	then

		# Fail
		api.std.failMsg "Script '${script##*/}' does not exist!"
		return 1

	fi
}

# Print the script to the command line
scriptctl.script.print ()
{
	scriptctl.script.getName "${1}"

	# If the script exists
	if [[ -f "${script}" ]]
	then
		
		# Print out the script
		cat ${script}
		return 0
	
	# If the script doesn't exist:
	else
	
		# Fail
		api.std.failMsg "${scriptname} does not exist!"
		return 1
	
	fi
}

# List all files in the scripts directory
scriptctl.scripts.list ()
{
	find $SCRIPTS/ -maxdepth 1 -type f -executable -exec basename {} \; | sort
	return 0
}

# Create the scripts directory if it does not already exist.
[[ ! -d "${SCRIPTS}" ]] && mkdir ${SCRIPTS}

# Set the subcommand to lowercase
cmd=`api.string.toLowerCase ${1}`

case "${cmd}" in
	c | create )
		scriptctl.script.create "${2}" "${3}"
		;;
	e | edit )
		scriptctl.script.edit "${2}"
		;;
	r | rename )
		scriptctl.script.rename "${2}" "${3}"
		;;
	d | delete )
		scriptctl.script.delete "${2}"
		;;
	p | print )
		scriptctl.script.print "${2}"
		;;
	l | list )
		scriptctl.scripts.list
		;;
	v | version )
		api.script.version
		;;
	\? | h | help )
		api.script.help
		;;
	* )
		[ -z "${cmd}" ] && api.script.help || api.errors.invalidCommand "${cmd}"
		;;
esac

# Exit the script with the last returned status code
exit $?
